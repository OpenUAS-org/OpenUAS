# OpenUAS – Authentication Flow

## Detailed Logical Flow (Pre-Spec, Non-Normative)

Status: Draft  
Scope: Authentication flow definition and security semantics

---

## Purpose of This Document

This document defines the **logical authentication flow** of OpenUAS.

It expands the Technical Design into:

- concrete step-by-step flows
- explicit data bindings
- security-relevant requirements
- failure and edge-case handling

This document still avoids:

- wire formats
- protocol syntax
- algorithm selection

Its purpose is to ensure **correct, interoperable, and secure behavior**
across independent implementations.

---

## High-Level Principles

All OpenUAS authentication flows MUST satisfy:

- Proof of possession, not proof of knowledge
- Single-use authentication material
- Explicit binding to the Relying Party
- Explicit binding to the authentication challenge
- No reusable credentials
- No silent fallback to weaker methods

---

## Actors Involved

- **User**: human initiating authentication
- **Client**: software acting on behalf of the user
- **Relying Party (RP)**: service requesting authentication

Optional actors (not part of the core flow):

- Registry
- Recovery services

---

## Identifiers and Terminology

### Relying Party Identifier (RPID)

Each Relying Party is identified by a stable identifier.

Examples:

- Web: origin (scheme + host + port)
- Native app: application identifier
- API service: cryptographic service ID

The RPID MUST be:

- stable
- unambiguous
- known to both Client and RP
- included in all cryptographic bindings

---

### Challenge

A Challenge is a fresh, unpredictable value generated by the RP.

Requirements:

- high entropy
- unique per authentication attempt
- time-bound (expiration)

Challenges MUST NOT be reused.

---

## Registration Flow

Registration establishes a cryptographic relationship between
the Client and the Relying Party.

### Preconditions

- The Client has identified the correct RPID
- The user has explicitly initiated registration
- No prior OpenUAS credential exists for this RPID on this Client

---

### Registration Steps

1. **Service Identification**
   - Client determines the RPID.
   - RPID MUST be validated against the execution context.

2. **Per-Service Key Creation**
   - Client generates or derives a per-service key pair.
   - Private key remains local and protected.
   - Public key is marked as RP-specific.

3. **User Authorization**
   - Client requests a local user confirmation
     (e.g. biometric, device unlock).
   - This authorizes use of the private key.

4. **Public Key Transmission**
   - Client sends the public key and RPID to the RP.
   - No secrets are transmitted.

5. **Server Registration**
   - RP stores the public key.
   - RP associates it with an internal account identifier.

Registration completes without shared secrets.

---

## Authentication Flow

Authentication proves possession of the per-service private key.

---

### Authentication Steps

1. **Authentication Request**
   - User initiates login.
   - RP identifies the account and issues an authentication challenge.

2. **Challenge Delivery**
   - RP sends the challenge to the Client.
   - Challenge includes expiration metadata.

3. **Client Validation**
   - Client verifies:
     - challenge freshness
     - correct RPID
     - matching registered key

4. **User Authorization**
   - Client requests explicit local user approval.
   - No remote prompts or codes are used.

5. **Proof Generation**
   - Client generates a proof bound to:
     - the challenge
     - the RPID
   - Proof MUST NOT be reusable.

6. **Proof Transmission**
   - Client sends the proof to the RP.

7. **Verification**
   - RP verifies:
     - proof validity
     - challenge freshness
     - correct RPID binding
     - public key match

8. **Authentication Result**
   - If valid → authentication succeeds
   - If invalid → authentication fails

---

## Proof Binding Requirements

Each authentication proof MUST be cryptographically bound to:

- the issued challenge
- the RPID
- the specific authentication event

A valid proof for one RP MUST be invalid for any other RP.

---

## Error Handling and Failure Modes

### Client-Side Failures

Examples:

- user denies authorization
- key unavailable
- RPID mismatch

Client behavior:

- authentication MUST abort
- no partial proofs sent
- no fallback attempted

---

### Server-Side Failures

Examples:

- invalid proof
- expired challenge
- unknown public key

RP behavior:

- authentication MUST fail closed
- no retry with weaker method
- no information leakage

---

## Replay Protection

Replay attacks are prevented by:

- single-use challenges
- challenge expiration
- proof binding

An RP MUST reject:

- reused challenges
- reused proofs
- delayed proofs outside validity window

---

## Phishing Resistance

Phishing resistance is achieved through:

- strict RPID binding
- client-side context validation
- non-exportable credentials
- absence of user-entered secrets

A Client MUST NOT generate proofs for mismatched contexts.

---

## Session Establishment (Out of Scope)

Session management occurs **after successful authentication**.

OpenUAS does NOT define:

- session cookies
- tokens
- refresh logic

These are responsibilities of the RP.

---

## Logging and Auditability

Implementations SHOULD:

- log authentication attempts
- record failure reasons
- support audit without exposing secrets

Logs MUST NOT contain:

- private keys
- reusable authentication material

---

## Summary

This document defines the **canonical OpenUAS authentication flow**.

It ensures:

- strong phishing resistance
- replay safety
- per-service isolation
- minimal user interaction
- predictable failure behavior

This flow is the foundation upon which
future OpenUAS protocol specifications will be built.

---
